#!/usr/bin/env ruby

require 'action_mailer'
require 'assignment_manager_service'
require 'cnu_namedpipe_service'
require 'cnu_tmail_mail'
require 'cnuregexp'

class MailmanService < CnuNamedPipeService
  def do_it file
    Mailman.receive(transcode(
      # Hack to pass route_type_cd into Mailman instance:
      file.read.sub(/(\nSubject:)/) {|s| "\nX-CNU-Route-Type-Code: #{pipe_cd}#{$&}" }
    ))
  end

  # This *may* be moot in Rails 1.2+:
  def transcode email
    email = 
      # Handle bad UTF-8 encoding (e.g. HotMail):
      # ... by grabbing or assuming charset and converting to UTF-8
      Iconv.new('utf-8', source_charset(email)).iconv(email) unless Kconv.isutf8(email)
      # ... by converting to Asian characters (not the best solution)
      #Kconv.toutf8(@email) unless Kconv.isutf8(@email)
    #logger.info "Kconv.isutf8(email): #{Kconv.isutf8(email).inspect}"
    email
  end

  # This *may* be moot in Rails 1.2+:
  def source_charset text
     charset = find_charset(text)
     # Don't try to convert from UTF-8 if charset claims UTF-8 
     # (remember: Kconv doesn't think this message is UTF-8):
     charset = nil if charset =~ /utf-8/i
     # assume ISO Latin 1 (Windows & Macintosh) if not found:
     charset || 'iso-8859-1'
  end

  # This *may* be moot in Rails 1.2+:
  def find_charset text
    charset = /Content-Type:.+charset="?([^"]+)"?$/i.match text
    #logger.info "charset: #{charset && charset[1]}"
    charset && charset[1]
  end
end

class Mailman < ActionMailer::Base

  FAX_RECEIVERS = %w[ loan_processing collections ]
  IGNORED_HEADERS = ["In Reply To"].freeze
  IGNORED_SUBJECT_KEYWORDS = ["Re:", "RE:"].freeze

  # Returns the brand of the inbound email from the To: address domain name
  # or any matching immediate subdomain.
  #
  # e.g. cashnetusa.com, cnu.cashetusa.com, issue.cashnetusa.com.
  #
  def brand
    @brand ||=
      Cnu::Brand.find_by_email_domain(to_domain) ||
      Cnu::Brand.find_by_email_domain(to_domain.sub(/^[^.]+\./, '')) ||
      (raise "Cannot determine brand from to_domain #{to_domain.inspect}")
  end


  # Returns the lower-case FQDN for the To: address of the inbound email.
  def to_domain
    @domain ||=
      @email.to.to_s.sub(/.*@/, '').downcase.freeze
  end

  def receive raw_email
    # Hack to receive route_type_cd from MailmanService:
    raw_email.route_type_cd = raw_email.header['x-cnu-route-type-code'].to_s
    # Although Hash#delete correctly returns the value,
    # it fails to delete the pair. If TMail fixes this, it should be used:
    #raw_email.route_type_cd = raw_email.header.delete('x-cnu-route-type-code').to_s

    #breakpoint "receive"
    @email = raw_email

    case raw_email.route_type_cd
    when 'responsys' : process_responsys_email
    else process
    end
  end

  # log emails sent to customers via responsys
  def process_responsys_email
    ActiveRecord::Base.troublemaker = @email.route_type_cd
    # Use delivered-to email header to determine the brand
    # Expecting delivered-to to be responsysbcc@issue.<<brand domain>>
    delivered_to_domain = @email.header['x-original-to'].to_s.sub(/.*@/, '').sub(/^[^.]+\./, '').downcase.strip
    for_brand = Cnu::Brand.find_by_email_domain(delivered_to_domain)

    @email.to_addrs.each do |to_address|
      @customer = Customer.find_by_email(to_address.address, for_brand)
      log_email("marketing_email", @customer.brand) if @customer
    end
  end

  def process
    return if self.is_junk?
    parse_email
    #breakpoint "process: #{@markers.inspect}"
    deliver_email
  end


  def is_junk?
    find_matches('skip') do |match_data|
      #breakpoint("Junk mail: " + @email.subject) if match_data
      return true if match_data
    end

    # Dump emails that look suspicous based on headers
    return true if (@email.from.to_s.length >= 255 || @email.to.to_s.length >=255)

    false
  end

  # parse_email uses find_matches to gather markers and select the
  # proper work_item_type (bucket):
  def parse_email
    @markers = {}

    #need to know locale to correctly parse phone/ssn
    @country_cd = brand.country.country_cd
    @locale = CnuLocale.instance(@country_cd)

    #logger.info "     rout_type_cd: #{@email.route_type_cd}"
    type_codes = if @email.route_type_cd == 'unsorted'
      CnuConfig.work_item_types.keys.reject {|item| item == 'skip' || item == 'unsorted'}
    else
      [@email.route_type_cd]
    end

    # Ensure customer_service is first so that route_type_cd can be
    # overwritten if later markers set a different work_item_type:
    type_codes.unshift( type_codes.delete('customer_service') ).compact!
    type_codes.unshift 'body_search'

    type_codes.each do |type_cd|
      #logger.info "parse_email; type_cd: #{type_cd}"
      #breakpoint "parse_email; type_cd: #{type_cd}"
      find_matches(type_cd) do |match_data|
        #logger.info "match_data.regexp: #{match_data.regexp.inspect}"

        # We've found a match, let's set the route_type_cd:
        # Matches in the body don't identify the work_item_type:
        @email.route_type_cd = type_cd unless type_cd == 'body_search' || freeze_route_type_cd?
        #logger.info "parse_email: route_type_cd: #{@email.route_type_cd.inspect}"
        match_data.regexp.tag_index.keys.inject(@markers) do |markers, key|
          #logger.info "  match_data['#{key.inspect}']: #{match_data[key].inspect}"
          markers[key] = match_data[key] unless match_data[key] == nil
          markers
        end # match_data ... do
      end # find_matches do
    end # type_codes.each do

    # Default to customer_service if it remains unsorted:
    @email.route_type_cd = 'customer_service' if @email.route_type_cd == 'unsorted'
    #breakpoint "get_markers: #{@markers.inspect}: #{@email.route_type_cd}"

    consolidate_compound_markers
    @markers.symbolize_keys!
    #logger.info "markers: #{@markers.inspect}"
  end

  def consolidate_compound_markers
    compound_markers = { localize_key(:phone_number) => @locale.phone.rx.ordered_keys, 
      "ssn" => %w(area_number group_number serial_number)}.symbolize_keys
    compound_markers.each do |new_key, old_keys|
      @markers[new_key] = @markers.values_at(*old_keys).compact.join('')
      @markers.reject! {|k,v| old_keys.include? k} if @markers[new_key]
      @markers.reject! {|k,v| @markers[k] == '' && new_key == k}
    end
  end

  # find_matches evaluates a block against an email using a 
  # work_item_type's criteria. (see work_item_types.yml) The criteria consist 
  # of the email parts (labeled by corresponding TMail method names, *and* 
  # downcased non-standard header keys) and Regexps (or strings). If the 
  # part's Regexp (or string converted to a Regexp) matches the part 
  # value, the block is evaluated.
  def find_matches work_item_type, &block
    criteria = work_item_type == 'body_search' ? 
                                  CnuConfig.work_item_types.unsorted.email.criteria : 
                                  CnuConfig.work_item_types.send(work_item_type.to_sym).email.criteria 


    criteria.each do |part, reg_arr_str|
      #logger.info "  part: #{part.inspect};"
      #logger.info "  part: #{part.inspect}; reg_arr_str: #{reg_arr_str.inspect}"

      # Use TMail's convenience methods for mail parts, first. Failing that, 
      # assume a non-standard header and use the TMail::Mail#header hash 
      # (e.g. for 'x-maxinfo', used to detect incoming faxes). Convert the 
      # resulting nil or TMail::UnstructuredHeader to a string:
      part_value = 
          if @email.respond_to?(part) then
            @email.send(part)
          else
            @email.header[part].to_s
          end

      unless part_value.blank?
        # TMail: From and To addresses are always arrays.
        # Let's treat everything that way for convenience of form:
        [*part_value].each do |part_value|
          #logger.info "    part_value: #{part_value.inspect}"
          #match_data = Regexp.union(*eval(reg_arr_str)).tag!.match part_value
  
          # Alternative approach here: take each regexp one at a time:
          [*eval(reg_arr_str)].each do |regexp_str|
            #logger.info "      regexp_str: #{regexp_str.inspect}"
            match_data = Regexp.union(regexp_str).tag!.match part_value
            #logger.info "       matching regexp: #{match_data.regexp}" if match_data
            yield(match_data) if match_data && match_data.regexp
          end # do
        end # do
      end # unless
    end # criteria.each do
  end # find_matches

  def deliver_email
    find_customer_etc
    log_email
    find_or_create_issue
    save_attachments
    create_or_reassign_work_item
    send_acknowledgment_email
  end

  # CHANGE LOG
  # ----------
  # - Modified for bug 66424 to allow for installments_collections issues
  #   MBillock 07-08-09, Issue 66424
  def find_customer_etc
    identified_by = nil

    localized_keys = %w(phone_number).map { |k| localize_key(k) }
    existing_keys = %w(loan_id customer_id area_code prefix suffix
        ssn area_number group_number serial_number issue_id
    )
    existing_keys.concat(localized_keys).reject! {|key| !@markers.stringify_keys.keys.include? key}

    existing_keys.each do |key|
      @customer ||= case key.to_sym
        when :loan_id
          @loan = Loan.find_by_id @markers[:loan_id]
          #identified_by = 'loan_id' if @loan
          @loan.customer if @loan
        when :customer_id
          #identified_by = 'customer_id'
          Customer.find_by_id @markers[:customer_id]
        when localize_key(:phone_number).to_sym
          person =  Person.find_by_any_phone @markers[localize_key(:phone_number)]
          #identified_by = 'phone' if person
          Customer.find_by_person_id_and_brand_id(person.to_id, brand.to_id) if person
        when :ssn
          person = Person.find_by_ssn @markers[:ssn]
          #identified_by = 'ssn' if person
          Customer.find_by_person_id_and_brand_id(person.to_id, brand.to_id) if person
        when :issue_id
          @issue = Issue.find_by_id @markers[:issue_id]
          #identified_by = 'issue_id' if @issue
          Customer.find_by_id(@issue.customer_id) if @issue
      end
    end

    #identified_by = 'email or not at all' unless @customer
    @customer ||= Customer.find_by_email(@email.from.to_s, brand)

    ActiveRecord::Base.troublemaker = @customer ?
      @customer.email :
      @email.from.to_s

    #bug 508179 - Hack to prevent customer_service_manager emails (fraud@cashnetusa.com and ops-qa-fl-gp@cashnetusa.com) from being
    #delievered incorrectly to collections
    return @customer if @email.route_type_cd == 'customer_service_manager'
 
    #per Lee : we change route_type_cd (and then below issue.type_cd) to 'collections' if customer in status 'in_default' or 'charged_off'  
    # modified for bug 66424 to create installments_collections issues - had to
    # change the logic to test the loan object for the customer
    # MBillock 07-08-09
    if @customer && (%w(in_default charged_off in_bankruptcy).include?(@customer.status_cd) || @customer.loans.any?{|loan| loan.status_cd=='charged_off'})
      # this checks to see if the current loan is an installment loan, in order
      # to apply the appropriate issue type to the generated work item
      # (installments collections is separated from regular collections as a
      # part of bug 66424)
      @email.route_type_cd = (@customer.loans.first.type_installment?) ? 'installments_collections' : 'collections'
    end
    return @customer
  end

  def log_email(type_cd="incoming_#{@email.route_type_cd}", email_brand=nil)
    email_brand ||= brand

    @email_record = EmailLog.create(
      :brand => email_brand,
      :created_by => ActiveRecord::Base.get_troublemaker,
      :text => [ @email.header_block, "\n\n***\n\n", @email.body ].join("\n\n"),
      :from_address => @email.from.to_s,
      :to_address => @email.to.to_s,
      :customer_id => @customer.to_id,
      :type_cd => type_cd
    )
  end

  def find_or_create_issue
    if @issue
      @issue.type_cd = @email.route_type_cd
      @issue.updated_by = ActiveRecord::Base.get_troublemaker
      @issue.save!
    else
      @issue = Issue.create(
        :created_by => ActiveRecord::Base.get_troublemaker,
        #:from_issue => @issue.to_id,
        # REFACTOR: Column should be renamed to origination_number.
        :from_issue => @markers[localize_key(:phone_number).to_sym],
        :customer => @customer,
        :loan => @loan,
        :type_cd => @email.route_type_cd,
        :brand => (@customer && @customer.brand) || brand
        #:target_time => (@target_time || nil),
        #:target_date => (@target_date || nil)
      )
      
      #logger.info "from_issue: #{@issue.from_issue}"
      #logger.info "customer_id: #{@issue.customer_id}"
      #logger.info "loan_id: #{@issue.loan_id}"
      #logger.info "type_cd: #{@issue.type_cd}"
    end

    @email_record.issue_id = @issue.to_id
    @email_record.save!

    return @issue
  end

  def save_attachments
    @email.attachments.each do |attachment|
      attachment_record = Attachment.create(
        :created_by => ActiveRecord::Base.get_troublemaker,
        :email_log_id => @email_record.to_id,
        :issue_id => @issue.to_id,
        :name => attachment.original_filename,
        :type_cd => attachment.content_type,
        :body => attachment.read
      )
    end if @email.attachments
  end

  def create_or_reassign_work_item
    priority_cd = @email.header['x-priority'] ? to_priority_cd(@email.header['x-priority'].to_s) : 'normal'
    workitem = @issue.current_work_item
    if workitem
      workitem.change("issue_#{@email.route_type_cd}", priority_cd, @issue.customer)
    else
      WorkItem.add_to_pool("issue_#{@email.route_type_cd}", nil, @loan, @issue, priority_cd, 'new', nil, brand)
    end
  end

  # Checks:
  # Verify that the to_address is enabled for auto-repsonse
  # Verify that the from_address is not blacklisted for auto-response 
  # Verify that the mail is not a reply from the sender
  # Verify that the mail is not an auto-response from the sender
  def send_acknowledgment_email 
    template_name = CnuConfig.mailman.acknowledgment_addresses &&
                    CnuConfig.mailman.acknowledgment_addresses.find{|x, y| y.include?(@email.to.to_s)}
     
    email_sender_ignored = CnuConfig.mailman.acknowledgment_ignore_addresses &&
                           CnuConfig.mailman.acknowledgment_ignore_addresses.find{|x| x.include?(@email.from.to_s)}

    return unless template_name
    return if email_sender_ignored
    return if reply_from_sender?
    return if auto_response_from_sender? 
  
    DataBaseMailer.run_email_sending(template_name.first, {:language_cd => brand.language.to_s,
                                                           :country_cd  => @country_cd, 
                                                           :brand_cd    => brand.to_s,
                                                           :customer    => @customer},
                                     false, {'to_instance' => {'email' => @email.from.to_s,
                                                              'contact_subject' => @email.subject.to_s,
                                                              'contact_body' => @email.body}})
  end

  private 
 
  def reply_from_sender? 
    IGNORED_HEADERS.any?{|x| @email.header_block.include? x} ||
    IGNORED_SUBJECT_KEYWORDS.any?{|x| @email.subject.include? x}
  end

  # Checks:
  # Last email sent by sender does not have the same subject as current email
  # We did not send the sender any emails in the past X minuetes
  # Allow blank subjects in new emails
  def auto_response_from_sender? 
    wait_period = CnuConfig.mailman.acknowledgment_wait_period
    # The current email is already saved and hence we need pull the one before that
    last_two_emails = EmailLog.find(:all, :conditions => ["from_address = ?" , @email.from.to_s], :order => "created_on desc", :limit => 2)
    last_email = last_two_emails ? last_two_emails[1] : nil  
    last_subject_field = last_email ? last_email.text.slice(/\nSubject:.*/) : ""
    last_subject = last_subject_field ? last_subject_field.sub("\nSubject:", "") : ""

    wait_period && last_email && ((last_subject.strip == @email.subject) || 
    EmailLog.find_by_to_address(@email.from.to_s, :conditions => ["created_on > (current_timestamp - interval ?)", wait_period]))
  end
  
  def freeze_route_type_cd?
    CnuConfig.mailman.frozen_route_types &&
    CnuConfig.mailman.frozen_route_types.any? {|route_type| route_type === @email.route_type_cd }
  end

  def to_priority_cd(x_priority)
    case x_priority.to_i
      when 1..2 
        'urgent'
      when 3
        'normal'
      when 4..5 
        'low'
      else 
        'normal'
    end
    
  end

  def localize_key(key)
    key.to_s + "_#{@country_cd.downcase}" if key.respond_to?(:to_s)
  end
 
end # class Mailman
